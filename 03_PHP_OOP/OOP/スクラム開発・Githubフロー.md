<h2 style="color: orange;">スクラム開発とは</h2>
まず始めにチーム開発で使用する開発手法についてスライドを使用して解説していきます。<br>
<br>
開発工程

(https://docs.google.com/presentation/d/e/2PACX-1vQLC58Jbp9oFqBiw9mvipdjkbKE9-KMENxgRhUPoHah5V3A8TwehLdqlen4epxPPC9N0R7hQTsq1VMY/embed?start=false&loop=false&delayms=3000)

チーム開発では最後のスライドで説明しているアジャイル開発の中の**スクラム**という手法を元に開発を進めます<br>

<h2 style="color: orange;">スクラム開発</h2>
皆さんが行うチーム開発で使用するアジャイル開発の中での開発手法、"スクラム開発"について、説明したいと思います。<br>
ちなみに、**スクラム**という言葉はラグビーで両陣が、8名ずつ肩を組んで一つの集団を作り、ぶつかり合う際のフォーメーション「スクラム」が語源。<br>その姿から集団が力を合わせることを”スクラムを組む”と表現することもある。<br>

### スクラム開発のメリット
大きく分けると5つあります。<br>
- 短い期間で、最大限の成果をあげる
- 作業の工数見積もりが正確になる
- 自立的なチーム作りができる
- チーム内で発生している問題の検知が早い
- 早めに軌道修正が出来る

#### 1.短い期間で、最大限の成果をあげる
スクラム開発では、優先順位の高い機能から順に開発を進めていきます。そのため短い期間であっても、あげられる成果が非常に高いのです。<br>

#### 2.作業の工数見積もりが正確になる
ウォーターフォール開発では、「プロジェクトの工数見積もりが上手くいかない」ということがデメリットとしてよく挙げられてきました。<br>
それもそのはずで、ウォーターフォール開発ではプロジェクトの最序盤の段階で数か月・数年も先のことを見積もりするため、そもそも難易度が極端に高いのです。<br>
スクラム開発では短い期間ごとに開発を区切り、その単位で計画を立てていくため、作業の工数見積もりは比較的正確になります。<br>
人は、数週間先くらいのことであれば予想しやすいからです。<br>

#### 3.自立的なチーム作りができる
スクラム開発では短く区切った開発期間ごとの工数見積もりを、各開発メンバーが自分で立て、期限を切ります。<br>
それに対しチームからの了承を得て進行するため、より一層各自に責任が発生するのです。<br>
セルフマネジメントはもちろん、自分のタスク以外も、チームの成果として計画を達成するにはどうしたらいいかを全員で考える必要があるので、それぞれの視野が広がり、自立的なチーム作りが促進できます。<br>

#### 4.チーム内で発生している問題の検知が早い
スクラム開発では、日々ミーティングを行います。その中で、「困っていること」や「分からないこと」を素直に話すことが推奨されているのです。<br>そのため、チーム内で問題が発生している場合でもすぐに検知することが出来ます。<br>

#### 5.早めに軌道修正が出来る
ウォーターフォール開発では、プロジェクトの最終盤にならなければ、顧客は動いているプロダクトを見ることが出来ません。<br>
そのため、納品した後に「思っていたものと違う！」とトラブルになるケースがよく発生していました。<br>
スクラム開発では、作っている機能が正しいか定期的に確認の場を設けるため、もし顧客の要望と違うものを作っていても早めに気付けるのです。<br>

<h2 style="color: orange;">スクラムチームの登場人物</h2><br>

1.プロダクトオーナー・ステークホルダー（講師が担当）

プロダクトに対して責任を持つ。プロダクトバックログの管理者

プロダクトバックログ：プロダクトへの要求の一覧。プロダクトオーナーが、作る順番に並べ替える（優先度の高い順etc）

2.スクラムマスター

スクラムがうまくいくようにする。外部からチームを守る（サーバント）

プロジェクトのケアをする人

3.開発チーム

チームで協力し合い、プロダクトの開発を行う

プロジェクトを推進していく

<h2 style="color: orange;">スクラム開発の進め方（詳細）</h2>
1. プロダクトバックログ作成
2. 完了の定義を決める
	- 何をもって完了とするかを定義
3. スプリント計画ミーティングの実施
	- プロダクトバックログを分析し、そのスプリントで開発するプロダクトバックログの項目を選択
	- また、選択した項目を個々の作業（タスク）に分解する
4. スプリントバックログ作成
	- 今季のスプリント期間中に行うタスクのリスト。
5. デイリースクラム実施
	- 毎日同じ時間、同じ場所で開発チームだけで行う。15分以内。
	- スプリントがゴールに向かって進んでいるか、作業の進捗がどうなっているか、問題点は無いか確認
6. スプリントレビュー
	- スプリント中の成果である、動作するソフトウェアのデモをする。
	- チームのベロシティを確認する。
7. リリース

### スプリントとは？
- PDCAを一周させる期間
- 通常１〜４週間で設定されることが多い

### ベロシティとは
- チームが１スプリントでこなせるタスク量
- スプリントを何周かまわすとチームの大まかな可能工数が見積もれ、やればやるほど正確になる

<br>
<img src="http://hackers.nexseed.net/images/curriculum_images/scrum_github1.png" style="width: 80%"><br>
<br>

### スクラム開発の進め方(講義用)
1. プロダクトバックログ作成
	- 機能リスト
2. 優先順位決め
	- 上記シートに上げた項目を優先順位順に並べ替え
3. デイリースクラム実施
	- 毎日同じ時間、同じ場所で開発チームだけで行う。15分以内。
	- スプリントがゴールに向かって進んでいるか、作業の進捗がどうなっているか、問題点は無いか確認
4. 成果レビュー
	- スプリント中の成果である、動作するソフトウェアのデモをする。

<h2 style="color: orange;">チーム開発Githubフロー</h2>
Git・Github・SourceTreeについては下記のカリキュラムをご覧ください。<br>

- <a href="http://hackers.nexseed.net/curriculums/72">Git</a><br>
- <a href="http://hackers.nexseed.net/curriculums/73">Github</a><br>
- <a href="http://hackers.nexseed.net/curriculums/75">SourceTree</a><br>

### 【基本作業フロー】
<br>
<img src="http://hackers.nexseed.net/images/curriculum_images/scrum_github2.png" style="width: 100%"><br>
<br>
1. リモートmasterブランチからローカルmasterブランチへpull <span style="color: red;">(※例外あり)</span><br>
2. トピックブランチを作成 <span style="color: red;">★★★注意★★★</span><br>
3. 開発 - commit<br>
4. ローカルトピックブランチからリモートトピックブランチへpush<br>
5. Pull Request<br>
6. マージ or 修正依頼<span style="color: red;">(※再push)</span><br>

### [※例外あり] について
下記の場合はpullではなくclone<br>
- 途中参加を含む、まだプロジェクトがローカル内に存在しない場合
- ローカルのmasterやトピックブランチが壊れてしまった場合

### [※再push]について
後日例題を元に実践しますが、PRをし管理者がチェックをした際何らかの修正依頼がありマージされなかったとします。<br>
その際にでる疑問としてそのままの状態(ブランチなど)修正を加えて良いのか、修正を加えたものはどこにpushすれば良いのかなどがあります。<br>
<br>
こちらの問題は、基本そのまま修正し、修正した内容をcommit。<br>
同じくpushもそのまますれば前回のPullRequest上に新たにpushされた修正内容が上積みされます。<br>
<br>
ローカルのmasterブランチを最新に保つチーム開発中、その日の最新のmasterブランチをリモートからPullし、新しくtopicブランチを作成して作業を進めます。<br>しかし次の日には他の開発者のPullRequestによりリモート上のmasterブランチは更新され、topicブランチを作成した昨日時点でのmasterブランチ(現在のローカルmasterブランチ)とは差分が発生してしまいます。<br>
<br>
実際の開発現場ではこういったやりとりが常日頃行われるため、下記手順を最低でも一日一回は行いローカルのmasterブランチを最新に保ち、すでに開発に着手しているtopicブランチにも最新のmasterブランチのデータをmergeしておく必要があります。<br>

<h2 style="color: orange;">【手順】</h2>
1. masterへCheckoutする<br>
  - topicブランチ上で変更していた内容についてはこの時点までに一度コミットしておく<br>
2. リモートmasterブランチからローカルmasterブランチへPullする<br>
  - ここでローカルのmasterブランチが他開発者の更新内容を取得し最新になる<br>
3. 再度topicブランチへCheckoutする<br>
	- topicブランチにmasterブランチの内容を吸収したいので、topicブランチ上から操作が必要なため<br>
4. masterブランチをtopicブランチへマージする (ローカル上で)<br>

<h2 style="color: orange;">【コンフリクトについて】</h2>
特に複数人で作業する際には十分に起き得るのですが、二つの分岐で不整合が起きてしまい、履歴としてその状態から進ませることができなくなります。<br>
これを**「コンフリクト」**といいます。<br>
コンフリクトはどのように起きるかというと<br>
<span style="font-size: 18px;">「同じ箇所を」「別々のブランチで」「別々の変更をかけてしまっているのに」「マージした時」</span><br>
に起こってしまいます。<br>
コンフリクトが発生した時を想定すると、結果的にどちらかのブランチの最新版を採用をしなければならない場合があります。<br>
そのため、**わかりやすいメッセージをつけて細かくコミットをしたり、別の分岐で同一ファイルを同時に触らないようにする**ことを開発の前に決めておいた方が良いでしょう。<br>

#### 【コンフリクトを起こして解決してみよう】
開発時はなるべく起こさせない方が良いのですが、今回はどのような時にコンフリクトが起きてしまうのか実験してみましょう。<br>
#### 準備
- htdocs直下にある自分のクラスのディレクトリに**"sample_githubディレクトリ"**を作成
- **下記のコードが記述されているindex.htmlをsample_github内に作成**

```
// sample_github/index.html

<!DOCTYPE html>
<html lang="ja">
<head>
	<meta charset="UTF-8">
	<title>index.html</title>
</head>
<body>
	sample
</body>
</html>
```
<br>
- github上**"sample_githubリポジトリ"**を作成<br>
- Initial Commitをする<br>
- SourceTreeでローカルで作成したsample_githubとGithubのリポジトリを紐づける。<br>
- masterをpushする<br>

### 実践
まず始めに、コンフリクトを起こすためにブランチ、**sample1**, **sample2**の二つ用意しましょう。<br>**二つともmasterからブランチを切るようにしましょう。**<br>
<br>
### sample1
<img src="http://hackers.nexseed.net/images/curriculum_images/scrum_github3.png" style="width: 80%"><br>
<br>
<br>
<br>
### sample2
<img src="http://hackers.nexseed.net/images/curriculum_images/scrum_github4.png" style="width: 80%"><br>
<br>
sample1・2ブランチを作成後、<span style="color: red;">sample1ブランチ内</span>でindex.htmlを下記のように変更し、コミットしてください。<br>
<br>
```
// sample_github/index.html (sample1ローカルブランチ内)

<!DOCTYPE html>
<html lang="ja">
<head>
	<meta charset="UTF-8">
	<title>index.html</title>
</head>
<body>
	test
</body>
</html>
```
<br>
コミット後、下の画像のように**ローカルのブランチと同じ名前(sample1)のブランチをリモートにプッシュ**します。<br>
<br>
<img src="http://hackers.nexseed.net/images/curriculum_images/scrum_github5.png" style="width: 80%"><br>
<br>
プッシュ後、ブラウザ上でsample_githubのgithubページを開くと、**Compare & pull request**ボタンが出現します。<br>
そのボタンをクリックしてPull Requestの画面に入ります。<br>
<br>
<img src="http://hackers.nexseed.net/images/curriculum_images/scrum_github6.png" style="width: 80%"><br>
<br>
そのまま、github上でsample1ブランチからのPullRequestをMergeします。<br>
<br>

### Pull Requestを作成
<img src="http://hackers.nexseed.net/images/curriculum_images/scrum_github7.png" style="width: 80%"><br>
<br>

### "Merge Pull Request"をクリック
<img src="http://hackers.nexseed.net/images/curriculum_images/scrum_github8.png" style="width: 80%"><br>
<br>

### "Confirm merge"をクリック
<img src="http://hackers.nexseed.net/images/curriculum_images/scrum_github9.png" style="width: 80%"><br>
<br>

以上でsample1のMergeは完了しました。<br>
次に、SourceTree上でローカルの**sample1からsample2にチェックアウト**します。<br>
チェックアウトしているかどうかの判断は下記の画像のようにブランチ名の横の丸がついているどうかです。<br>
<br>
<img src="http://hackers.nexseed.net/images/curriculum_images/scrum_github10.png" style="width: 80%"><br>
<br>
チェックアウト後、下記のようにindex.htmlを変更し、コミットします。<br>
<br>

```
// sample_github/index.html (sample2ローカルブランチ内)

<!DOCTYPE html>
<html lang="ja">
<head>
	<meta charset="UTF-8">
	<title>index.html</title>
</head>
<body>
	テスト
</body>
</html>
```
<br>
sample1ブランチ同様にコミットをしてください。<br>
<br>
<img src="http://hackers.nexseed.net/images/curriculum_images/scrum_github11.png" style="width: 80%"><br>
<br>
コミット後はsample1と同様、sample2のリモートブランチにプッシュしてください。<br>
プッシュ後、ブラウザ上でsample_githubのgithubページを開くと、**Compare & pull request**ボタンが出現します。<br>
<br>
<img src="http://hackers.nexseed.net/images/curriculum_images/scrum_github12.png" style="width: 80%"><br>
<br>
すると、先ほどPullRequestしたsample1のような表示ではなく、下記のような表示になっています。<br>
<br>
<img src="http://hackers.nexseed.net/images/curriculum_images/scrum_github13.png" style="width: 80%"><br>
<br>
**「Can't automatically merge」**という表示なっています。<br>
今回はここを無視してPullRequestします。(今回はコンフリクトを起こすためなので通常では開発手法に則って動いてください)<br>
そうするとPull Requestの画面に**「This blance has conflicts that must be resolved」**と出ています。<br>
これは**コンフリクトを起こしている証拠**です。<br>
<br>
<img src="http://hackers.nexseed.net/images/curriculum_images/scrum_github14.png" style="width: 80%"><br>
<br>
**Resolve Conflicts**のボタンを押すと編集画面のようなエディタが出てきます。<br>
<br>
<img src="http://hackers.nexseed.net/images/curriculum_images/scrum_github15.png" style="width: 80%"><br>
<br>

```
<<<<<<< sample2
  テスト
=======
  test
>>>>>>> master
```
<br>
上記の部分はGithubがわかりやすくコンフリクトを起こしている箇所を指し示しています。<br>
=(イコール)より上の記述がPull Requestをしたファイルで、下の記述がPull Request先です。<br>
**コンフリクトを解決するには、このどちらかを残して、他方を削除すればOKです。**<br>
また、Gitが追加してくれた**「<<<<<<<< hogehoge」「=======」「>>>>>>>> hogehoge」**も合わせて全部削除する必要があります。<br>
今回はmaster側の**test**を使用したいと思います。下記のように編集しましょう。<br>
<br>
<img src="http://hackers.nexseed.net/images/curriculum_images/scrum_github16.png" style="width: 80%"><br>
<br>
記述が終わり次第、**「Mark as resolved」**をクリックして、出現した**「Commit merge」**をクリックしましょう。<br>
<br>
<img src="http://hackers.nexseed.net/images/curriculum_images/scrum_github17.png" style="width: 80%"><br>
<br>
Commit merge後、下記のようにコンフリクトがなく、Mergeができるようになります。<br>
<br>
<img src="http://hackers.nexseed.net/images/curriculum_images/scrum_github18.png" style="width: 80%"><br>
<br>


<h2 style="color: orange;">【PullRequest(PR)上でディスカッションしながら開発を進める】</h2>
コードを共有しディスカッションをするための機能がGithubには存在し、PRをひとつの掲示版のような単位で考え使うことができます。<br>
Topicブランチを一度PRしておくと、その後の同じブランチ内でのプッシュはすべて同じPR上に上乗せされていきます。これはそのPRがマージされるまで続きます。<br>

#### 【Topicブランチにて開発したかった内容をMasterブランチに誤ってcommitしてしまった場合の対処法】
1. Master上でコミットを戻す
	- 戻したいコミットデータの上で右クリック → このコミットまで元に戻す
2. Topicブランチへチェックアウト
	- 変更を保持したまま (チェック入れずに)
3. Topicブランチに変更をadd, commit

## 参考
- [いまさらだけどGitを基本から分かりやすくまとめてみた](https://qiita.com/gold-kou/items/7f6a3b46e2781b0dd4a0)
  - 復習にもなりますので確認してみてください
